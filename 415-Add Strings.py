class Solution:\u000A    def addStrings(self, num1: str, num2: str) \u002D\u003E str:\u000A        ans \u003D []\u000A        n1 \u003D len(num1)\u000A        n2 \u003D len(num2)\u000A        # 保证n1 \u003E\u003D n2,从而可以将结果直接存放在1中,并且不用做过多判断\u000A        if n1 \u003C n2:\u000A            num1,num2 \u003D num2,num1\u000A            n1,n2 \u003D n2,n1\u000A        s1 \u003D [int(x) for x in num1]\u000A        s2 \u003D [int(x) for x in num2]\u000A        # 倒序存储,便于将来处理进位\u000A        s1 \u003D s1[::\u002D1]\u000A        s2 \u003D s2[::\u002D1]\u000A        for i in range(n2):\u000A            s1[i] +\u003D s2[i]\u000A        \u000A        def CarrySolver(arr):\u000A            i \u003D 0\u000A            while i \u003C len(arr):\u000A                if arr[i] \u003E\u003D 10:\u000A                    ad \u003D arr[i] // 10\u000A                    if i + 1 \u003D\u003D len(arr):\u000A                        arr.append(ad)\u000A                    else:\u000A                        arr[i + 1] +\u003D ad\u000A                    arr[i] %\u003D 10\u000A                i +\u003D 1\u000A            return arr\u000A        \u000A        ans \u003D \u0027\u0027.join([str(x) for x in CarrySolver(s1)][::\u002D1])\u000A        return ans\u000A\u000A        \u0027\u0027\u0027\u000A        ans \u003D []\u000A        ad \u003D 0\u000A        n1 \u003D len(num1)\u000A        n2 \u003D len(num2)\u000A        for i in range(max(n1,n2)):\u000A            a \u003D int(num1[\u002Di\u002D1] if i \u003C n1 else 0)\u000A            b \u003D int(num2[\u002Di\u002D1] if i \u003C n2 else 0)\u000A            t \u003D a + b + ad\u000A            ad,m \u003D divmod(t,10)\u000A            ans.append(m)\u000A        while ad \u003E 0:\u000A            ad,m \u003D divmod(ad,10)\u000A            ans.append(m)\u000A        ans.reverse()\u000A        return \u0027\u0027.join(map(str,ans))\u000A        \u0027\u0027\u0027