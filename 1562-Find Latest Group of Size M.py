class Solution:\u000A    def findLatestStep(self, arr: List[int], m: int) \u002D\u003E int:\u000A        # 并查\u000A        # l[i]表示以i为边界的连续的1的长度(包括向左和向右),由于连续1中间的数字无意义(不需要再被考虑,所以不需要更新)\u000A        # cnt[i]表示长度为i的连续1的子串数量\u000A        n \u003D len(arr)\u000A        l \u003D [0] * (n + 2)\u000A        cnt \u003D [0] * (n + 1)\u000A        # 每一步,都使l[arr[i] \u002D 1]和l[arr[i] + 1]被连接起来\u000A        # 新长度newLen \u003D l[arr[i] \u002D 1] + l[arr[i] + 1] + 1\u000A        # 于是,l[arr[i] \u002D l[arr[i] \u002D 1]] \u003D newLen,l[arr[i] + l[arr[i] + 1]] \u003D newLen\u000A        # cnt[l[arr[i] \u002D 1]] \u002D\u003D 1,cnt[l[arr[i] + 1]] \u002D\u003D 1\u000A        # cnt[newLen] +\u003D 1\u000A        ans \u003D \u002D1\u000A        for i in range(n):\u000A            left \u003D l[arr[i] \u002D 1]\u000A            right \u003D l[arr[i] + 1]\u000A            newLen \u003D left + right + 1\u000A            l[arr[i] \u002D left] \u003D l[arr[i] + right] \u003D newLen\u000A            cnt[left] \u002D\u003D 1\u000A            cnt[right] \u002D\u003D 1\u000A            cnt[newLen] +\u003D 1\u000A            if cnt[m] \u003E 0:  # 还有满足条件的,则记录下来\u000A                ans \u003D i + 1\u000A            #print(left,right,l,cnt,ans)\u000A        return ans\u000A        \u000A        \u0027\u0027\u0027\u000A        # 二分法,O(NlogN)\u000A        # 反过来想\u000A        # 原来是一个全1的二进制字符串,将arr[::\u002D1]的位置依次变为0\u000A        # 用二分查找,左右设置哨兵\u000A        n \u003D len(arr)\u000A        if m \u003D\u003D n:\u000A            return n\u000A        bits \u003D [0,n + 1]\u000A        for i in range(1,n + 1):\u000A            p \u003D bisect.bisect_left(bits,arr[\u002Di])\u000A            #print(bits,arr[\u002Di],p)\u000A            bisect.insort_left(bits,arr[\u002Di])\u000A            #print(bits,p)\u000A            if bits[p] \u002D bits[p \u002D 1] \u003D\u003D m + 1 or bits[p + 1] \u002D bits[p] \u003D\u003D m + 1:\u000A                return n \u002D i\u000A        return \u002D1\u000A        \u0027\u0027\u0027