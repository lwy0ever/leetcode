class Solution:\u000A    def containsCycle(self, grid: List[List[str]]) \u002D\u003E bool:\u000A        # 从[a,b]开始bfs,如果能通过不同的路径到达[c,d],则说明存在环\u000A        # 由于是不同路径,也就是环的长度大于等于1 + 2 + 1\u003D4\u000A        # 由于不能斜向走,所以到达[c,d]的时候,所需步数是一样的\u000A        m \u003D len(grid)\u000A        n \u003D len(grid[0])\u000A        di \u003D [[\u002D1,0],[1,0],[0,\u002D1],[0,1]]\u000A        visited \u003D set()\u000A        for i in range(m):\u000A            for j in range(n):\u000A                if (i,j) in visited:\u000A                    continue\u000A                a \u003D grid[i][j]\u000A                #print(i,j)\u000A                fromP \u003D {(i,j)}\u000A                visited.add((i,j))\u000A                while fromP:\u000A                    toP \u003D set()\u000A                    for f in fromP:\u000A                        for d in di:\u000A                            if 0 \u003C\u003D f[0] + d[0] \u003C m and 0 \u003C\u003D f[1] + d[1] \u003C n and grid[f[0] + d[0]][f[1] + d[1]] \u003D\u003D a:\u000A                                if (f[0] + d[0],f[1] + d[1]) in toP:\u000A                                    return True\u000A                                if (f[0] + d[0],f[1] + d[1]) not in visited:\u000A                                    toP.add((f[0] + d[0],f[1] + d[1]))\u000A                                    visited.add((f[0] + d[0],f[1] + d[1]))\u000A                    fromP \u003D toP\u000A                    #print(fromP)\u000A        return False