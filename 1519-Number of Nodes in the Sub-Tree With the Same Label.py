class Solution:\u000A    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) \u002D\u003E List[int]:\u000A        d \u003D collections.defaultdict(list)\u000A        for a,b in edges:\u000A            d[a].append(b)\u000A            d[b].append(a)\u000A        ans \u003D [0] * n\u000A        visited \u003D set()\u000A        \u000A        def dfs(i): # 返回所有子树的标签数量\u000A            visited.add(i)\u000A            cnt \u003D collections.Counter({})   # 这里一定要{},确保会新生成一个Counter\u000A            for t in d[i]:\u000A                if t not in visited:\u000A                    cnt +\u003D dfs(t)\u000A            cnt[labels[i]] +\u003D 1 # 包含自身\u000A            #print(i,cnt,id(cnt))\u000A            ans[i] \u003D cnt[labels[i]]\u000A            return cnt\u000A        \u000A        dfs(0)\u000A        return ans