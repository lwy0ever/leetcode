class Solution:\u000A    def minSwaps(self, grid: List[List[int]]) \u002D\u003E int:\u000A        # \u0022主对角线以上的格子全部都是0\u0022也就是右上角都是0\u000A        n \u003D len(grid)\u000A        first1 \u003D [0] * n    # 记录每一行从右往左,第一个1出现的位置\u000A        for i in range(n):\u000A            for j in range(n \u002D 1,\u002D1,\u002D1):\u000A                if grid[i][j] \u003D\u003D 1:\u000A                    first1[i] \u003D j\u000A                    break\u000A        # 如果最终满足要求,那么第i行的first1[i] \u003C\u003D i\u000A        # 设i \u003C j,那么first1[i] \u003C\u003D i,first1[j] \u003C\u003D j,可以放置于第i行的,一定可以放置在第j行\u000A        # 也就是说,不会存在第j行占用了本应放置于第i行的情况\u000A        # 所以,在考虑第i行的时候,只需要找到第一个满足i行要求的即可\u000A        ans \u003D 0\u000A        noUsed \u003D [i for i in range(n)]\u000A        for i in range(n):  # 考虑第i行\u000A            for j in range(n \u002D i):  # 剩余n \u002D i行可用\u000A                if first1[noUsed[j]] \u003C\u003D i:   # 第j行可用\u000A                    ans +\u003D j    # 上移j行\u000A                    noUsed.pop(j)\u000A                    break\u000A            else:\u000A                return \u002D1\u000A        return ans